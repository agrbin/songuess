/*jslint indent: 2, plusplus: true*/
'use strict';

var currentEnv = process.env.NODE_ENV || 'developement';

exports.server = {
  // where to listen.
  port  : 8080,

  // this file will be served when server
  // is hit with GET / .. or null
  indexHtml : null,

  // if htdocsDir is set, master will serve files from that dir to http
  // clients. content-types are set only for html, js and css
  htdocsDir : null,

  // if set, this field will be sent with static files as 'Cache-Control:
  // max-age='
  // or null not to send that header.
  staticMaxAge : null.

  // when set to true static file will be re-read for every request.
  // this option should not be used on production. this option will turn
  // off previous option (caching).
  readFileOnRequest : false 
};

// ping will be sent  every pingInterval seconds to client
// to keep the connection alive across non patient firewalls.
// if socket notices sleepyPeriod seconds without user activity, that user will
// be disconnected.
exports.socket = {
  pingInterval : 60,
  sleepyPeriod : 30 * 60
};

// server and client have synced clocks. if chunk is to be played less than
// sendAhead seconds in the future, dispatch process for that chunk will begin.
// every setTimeout-ed 0.5 seconds streamer will check above condition.
// note that if proxy is available this time will be cutted for
// proxy.throttleStream value.
// overlapTime
//  is overlapping between chunks to make seamless playback on
//  client. this constant is copied to ../client/player.js
//
// chunkDuration
//  is chunk duration! it is copied to lib/frames.cpp
//
exports.streamer = {
  sendAhead     : 8,
  checkInterval : 0.5,
  chunkDuration : 2.448,
  overlapTime   : 0.048,
};

// synchronization params.
exports.sync = {
  numberOfSamples   : 10,
  maxClockDeviation : 10,
  maxPing           : 1000
};

exports.media = {
  'media1' : {
    endpoint  : 'http://localhost:8081',
    desc      : 'grbinov media server'
  },
  'media2' : {
    endpoint  : 'http://localhost:8081',
    desc      : 'grbinov klon media server'
  }
};

exports.auth = {
  clientID    :  'XYZ.apps.googleusercontent.com',
  verifyURL   :  'https://www.googleapis.com/oauth2/v1/tokeninfo',
  profileURL  :  'https://www.googleapis.com/oauth2/v1/userinfo',
  scope       :  [
    'https://www.googleapis.com/auth/userinfo.profile',
    'https://www.googleapis.com/auth/userinfo.email'
  ]
};

exports.proxy = {
  // you can bypass proxy with this.
  enable  : true,

  // time period before proxy sends out the stream.
  // it is used to warm-up cache.
  // throttle delay will be calculated:
  //   delay = Off + (rand() * 2 - 1) * Amp
  throttleStreamOff : 2,
  throttleStreamAmp : 2,

  // where will proxy serve chunks
  urlPrefix : '/c/',

  // you can add extension to a chunk
  urlSuffix : '',

  // maximum number of seconds for media server to
  // send a chunk. after this we will issue 504 gateway
  // timeout to clients requesting that chunk.
  maxDelay : 1,

  // time that the URL returned from proxify will be available.
  maxAge : 60,

  // primary url sent to clients
  // if this timeout's secondary url will be queried
  cdnHttpRoot : 'http://localhost:8080',

  // secondary url.
  httpRoot : null

};
